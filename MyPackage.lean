
import Lean

import MyPackage.Base
import MyPackage.Notation
import MyPackage.Groundwork

open Classical

set_option codegen false

universe u

inductive Term (Œ± : Type u) (Œ≤ : Type u)
  | Cst (c : Œ±)
  | Var (x : Œ≤)
  | Cons (t‚ÇÅ : Term Œ± Œ≤) (t‚ÇÇ : Term Œ± Œ≤)

section

variable {Œ± : Type u} {Œ≤ : Type u}

def map_reduce (Œ∏ : Œ≤ ‚Üí Term Œ± Œ≤) (u : Term Œ± Œ≤) : Term Œ± Œ≤ := match u with
  | Term.Cst c => Term.Cst c
  | Term.Var x => Œ∏ x
  | Term.Cons t‚ÇÅ t‚ÇÇ => Term.Cons (map_reduce Œ∏ t‚ÇÅ) (map_reduce Œ∏ t‚ÇÇ)

def comp (f g : Œ≤ ‚Üí Term Œ± Œ≤) (x : Œ≤) : Term Œ± Œ≤ :=
  map_reduce g (f x)

theorem map_one (u : Term Œ± Œ≤) : map_reduce Term.Var u = u :=
  by induction u with
  | Cst c => rfl
  | Var x => rfl
  | Cons t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ => simp [map_reduce, ht‚ÇÅ, ht‚ÇÇ]

theorem map_comp (u : Term Œ± Œ≤) (f g : Œ≤ ‚Üí Term Œ± Œ≤) :
  map_reduce g (map_reduce f u) = map_reduce (comp f g) u := by induction u with
  | Cst c => rfl
  | Var x => rfl
  | Cons t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ => simp [map_reduce, ht‚ÇÅ, ht‚ÇÇ]

instance fun_monoid : Monoid (Œ≤ ‚Üí Term Œ± Œ≤) where
  one := Term.Var
  mul := comp
  one_mul := by intros; rfl
  mul_one := by intros; funext x; apply map_one
  mul_assoc := by intros; funext x; apply map_comp

instance term_action : RAction (Term Œ± Œ≤) (Œ≤ ‚Üí Term Œ± Œ≤) where
  smul x Œ∏ := map_reduce Œ∏ x
  smul_one := map_one
  smul_mul := map_comp

end

section

def Subst (Œ± : Type u) (Œ≤ : Type u) := { f : Œ≤ ‚Üí Term Œ± Œ≤ // finite { x : Œ≤ // f x ‚â† Term.Var x } }

private theorem comp_carrier {f g : Œ≤ ‚Üí Term Œ± Œ≤} {x : Œ≤} :
  ((f * g) x ‚â† Term.Var x) ‚Üí f x ‚â† Term.Var x ‚à® g x ‚â† Term.Var x := by
  rw [‚Üê Decidable.not_and_iff_or_not]
  apply contrapose
  exact Œª ‚ü® h‚ÇÅ, h‚ÇÇ ‚ü© => by simp [HMul.hMul, Mul.mul, comp, map_reduce, h‚ÇÅ, h‚ÇÇ]

private def carriers_arrow (f g : Œ≤ ‚Üí Term Œ± Œ≤) : ({ x : Œ≤ // (f * g) x ‚â† Term.Var x }) ‚Üí
  { x // f x ‚â† Term.Var x } ‚äï { x // g x ‚â† Term.Var x } :=
  Œª ‚ü® x, p ‚ü© =>
    if hf : f x ‚â† Term.Var x then Sum.inl ‚ü® x, hf ‚ü©
    else if hg : g x ‚â† Term.Var x then Sum.inr ‚ü® x, hg ‚ü©
    else False.elim <| match comp_carrier p with
    | Or.inl p => hf p
    | Or.inr p => hg p

private theorem carriers_arrow_inj (f g : Œ≤ ‚Üí Term Œ± Œ≤) (x y : {x // (f * g) x ‚â† Term.Var x})
  (h : carriers_arrow f g x = carriers_arrow f g y) : x = y := by
  revert x y
  intro ‚ü® x, hx ‚ü© ‚ü® y, hy ‚ü© h
  apply Subtype.eq
  simp [carriers_arrow] at h
  have x_nontriv : {P : Prop} ‚Üí ¬¨ f x ‚â† Term.Var x ‚Üí ¬¨ g x ‚â† Term.Var x ‚Üí P :=
    Œª p q => False.elim <| match comp_carrier hx with | Or.inl r => p r | Or.inr r => q r
  have y_nontriv : {P : Prop} ‚Üí ¬¨ f y ‚â† Term.Var y ‚Üí ¬¨ g y ‚â† Term.Var y ‚Üí P :=
    Œª p q => False.elim <| match comp_carrier hy with | Or.inl r => p r | Or.inr r => q r
  byCases p‚ÇÅ : f x ‚â† Term.Var x <;> byCases p‚ÇÇ : g x ‚â† Term.Var x
    <;> byCases p‚ÇÉ : f y ‚â† Term.Var y <;> byCases p‚ÇÑ : g y ‚â† Term.Var y
    <;> simp [dif_pos p‚ÇÅ, dif_neg p‚ÇÅ, dif_pos p‚ÇÇ, dif_neg p‚ÇÇ,
      dif_pos p‚ÇÉ, dif_neg p‚ÇÉ, dif_pos p‚ÇÑ, dif_neg p‚ÇÑ] at h
    <;> first
      | assumption
      | apply x_nontriv; assumption; assumption
      | apply y_nontriv; assumption; assumption

instance : Monoid (Subst Œ± Œ≤) where
  one := ‚ü® Term.Var, ‚ü® [], Œª ‚ü® _, p ‚ü© => p rfl ‚ü© ‚ü©
  mul := Œª ‚ü® f, pf ‚ü© ‚ü® g, pg ‚ü© =>
    ‚ü® f * g, invimage_finite_of_inj (sum_finite pf pg) (carriers_arrow_inj f g) ‚ü©
  one_mul := Œª ‚ü® _, _ ‚ü© => rfl
  mul_one := Œª ‚ü® _, _ ‚ü© => Subtype.eq <| fun_monoid.mul_one _
  mul_assoc := Œª ‚ü® _, _ ‚ü© ‚ü® _, _ ‚ü© ‚ü® _, _ ‚ü© => Subtype.eq <| fun_monoid.mul_assoc _ _ _

instance subst_self_action : RAction (Subst Œ± Œ≤) (Subst Œ± Œ≤) := self_action _

instance subst_term_action : RAction (Term Œ± Œ≤) (Subst Œ± Œ≤) where
  smul := Œª x ‚ü® f, hf ‚ü© => x ‚Ä¢ f
  smul_one := term_action.smul_one
  smul_mul := Œª _ ‚ü® _, _ ‚ü© ‚ü® _, _ ‚ü© => term_action.smul_mul _ _ _

def carrier (Œ∏ : Subst Œ± Œ≤) : Fintype Œ≤ :=
  match Œ∏ with
  | ‚ü® Œ∏, h ‚ü© =>
    let œÄ : {x // Œ∏ x ‚â† Term.Var x} ‚Üí Œ≤ := Œª ‚ü® x, _ ‚ü© => x
    Fintype.mk <| List.map œÄ (epsilon <| Œª l => ‚àÄ a, List.mem a l)

def carrier_spec {Œ∏ : Subst Œ± Œ≤} {y : Œ≤} :
  y ‚àà carrier Œ∏ ‚Üî (Term.Var y : Term Œ± Œ≤) ‚Ä¢ Œ∏ ‚â† Term.Var y :=
  match Œ∏ with
  | ‚ü® Œ∏, hŒ∏ ‚ü© => by
    apply Iff.intro
    focus
      intro h
      let ‚ü® ‚ü® x, hx ‚ü©, ‚ü® _, h‚ÇÇ ‚ü© ‚ü© := List.mem_map_iff_image.1 h
      exact h‚ÇÇ ‚ñ∏ hx
    focus
      let œÄ : {x // Œ∏ x ‚â† Term.Var x} ‚Üí Œ≤ := Œª ‚ü® x, _ ‚ü© => x
      intro h'
      rw [show y = œÄ ‚ü® y, h' ‚ü© from rfl]
      apply List.mem_map
      apply epsilon_spec hŒ∏

def subst_cons {u v : Term Œ± Œ≤} {Œ∏ : Subst Œ± Œ≤} :
  Term.Cons u v ‚Ä¢ Œ∏ = Term.Cons (u ‚Ä¢ Œ∏) (v ‚Ä¢ Œ∏) := by
  cases Œ∏; rfl

end 

section

variable {Œ± Œ≤ : Type u}

def depth : (u : Term Œ± Œ≤) ‚Üí Nat
| Term.Cst _ => 0
| Term.Var _ => 0
| Term.Cons l r => depth l + depth r + 1

theorem depth_decr_l (l r : Term Œ≤ Œ±) : depth l < depth (Term.Cons l r) :=
  Nat.lt_succ_of_le <| Nat.le_add_right _ _

theorem depth_decr_r (l r : Term Œ≤ Œ±) : depth r < depth (Term.Cons l r) :=
  Nat.lt_succ_of_le <| Nat.le_add_left _ _

def Term.depth_wfRel : WellFoundedRelation (Term Œ± Œ≤) := measure depth

end

section

variable {Œ± : Type u}

theorem included_refl {a : Fintype Œ±} : a ‚äÜ a := sorry

theorem included_trans {a b c : Fintype Œ±} (h : a ‚äÜ b) (h' : b ‚äÜ c) : a ‚äÜ c := by
  admit

theorem empty_included (a : Fintype Œ±) : ‚àÖ ‚äÜ a := sorry

theorem union_on_included {a b c d : Fintype Œ±}
  (h‚ÇÅ : a ‚äÜ b) (h‚ÇÇ : c ‚äÜ d) : a ‚à™ c ‚äÜ b ‚à™ d := by
  admit

theorem union_included_iff {a b c : Fintype Œ±} : a ‚à™ b ‚äÜ c ‚Üî a ‚äÜ c ‚àß b ‚äÜ c := sorry

theorem included_union_iff {a b c : Fintype Œ±} : a ‚äÜ b ‚à™ c ‚Üî a ‚äÜ b ‚à® a ‚äÜ c := sorry

theorem mem_of_subset_mem {x y : Fintype Œ±} {a : Œ±} (h : x ‚äÜ y) : a ‚àà x ‚Üí a ‚àà y := sorry

theorem not_mem_of_superset_not_mem {x y : Fintype Œ±} {a : Œ±} (h : x ‚äÜ y) :
  ¬¨ a ‚àà y ‚Üí ¬¨ a ‚àà x := contrapose (mem_of_subset_mem h)

theorem mem_iff_singleton_included {x : Fintype Œ±} {a : Œ±} : a ‚àà x ‚Üî (Fintype.mk [a]) ‚äÜ x := sorry

theorem not_mem_iff_in_without {x : Fintype Œ±} {a : Œ±} :
  ¬¨ a ‚àà x ‚Üî x ‚äÜ x \ Fintype.mk [a] := sorry

theorem included_without_of_included {a b: Fintype Œ±} (c : Fintype Œ±) (h : a ‚äÜ b) :
  a \ c ‚äÜ b \ c := sorry

theorem union_comm (a b : Fintype Œ±) : a ‚à™ b = b ‚à™ a := sorry

theorem union_idempotent (a : Fintype Œ±) : a ‚à™ a = a := sorry

/- Two hacky lemmas, would be best with a tactic. -/
theorem flush_union_left (a : Fintype Œ≤) : ‚àÄ b c, c ‚à™ b ‚à™ a = c ‚à™ a ‚à™ b := sorry

theorem union_idempotent' (a b : Fintype Œ≤) : a ‚à™ b ‚à™ b = a ‚à™ b := sorry

end

section

variable {Œ± Œ≤ : Type u}

def Term.vehicle : Term Œ± Œ≤ ‚Üí Fintype Œ≤
| Term.Cst _ => ‚àÖ
| Term.Var x => Fintype.mk [x]
| Term.Cons l r => vehicle l ‚à™ vehicle r

instance : HasVehicle (Term Œ± Œ≤) (Fintype Œ≤) where
  vehicle := Term.vehicle

def Subst.vehicle (Œ∏ : Subst Œ± Œ≤) : Fintype Œ≤ := Fintype.image
  (Œª x => ùí± ((Term.Var x : Term Œ± Œ≤) ‚Ä¢ Œ∏)) (carrier Œ∏)

instance : HasVehicle (Subst Œ± Œ≤) (Fintype Œ≤) where
  vehicle := Subst.vehicle

theorem vehicle_cons {u v : Term Œ± Œ≤} : 
  (ùí± (Term.Cons u v) : Fintype Œ≤) = ùí± u ‚à™ ùí± v := rfl

theorem vehicle_on_image {Œ∏ : Subst Œ± Œ≤} {A : Fintype Œ≤}
  (h‚ÇÅ : ùí± Œ∏ ‚äÜ A) (u : Term Œ± Œ≤) :
  ùí± (u ‚Ä¢ Œ∏) ‚äÜ A ‚à™ ùí± u := by
    induction u with
    | Cst c => cases Œ∏; apply empty_included
    | Var x =>
      byCases h : (Term.Var x : Term Œ± Œ≤) ‚Ä¢ Œ∏ = Term.Var x
      focus
        apply included_union_iff.2 ‚àò Or.inr
        rw [h]
        exact included_refl
      focus
        apply included_union_iff.2 ‚àò Or.inl
        apply included_trans _ h‚ÇÅ
        exact Fintype.in_image_of_is_image <| carrier_spec.2 h
    | Cons l r hl hr =>
      rw [subst_cons]
      simp only [Term.vehicle]
      apply included_trans (union_on_included hl hr)
      conv =>
        rhs
        rw [vehicle_cons, ‚Üê Fintype.union_assoc]
        rw [‚Üê union_idempotent A]
        conv =>
          lhs
          conv => rw [Fintype.union_assoc]; rhs; rw [union_comm]
          rw [‚Üê Fintype.union_assoc]
        rw [Fintype.union_assoc]
      exact included_refl

theorem vehicle_on_image_contained {Œ∏ : Subst Œ± Œ≤} {A : Fintype Œ≤} {u : Term Œ± Œ≤}
  (h‚ÇÅ : ùí± Œ∏ ‚äÜ A) (h‚ÇÇ : ùí± u ‚äÜ A) : ùí± (u ‚Ä¢ Œ∏) ‚äÜ A :=
  included_trans (vehicle_on_image h‚ÇÅ u) <|
    union_included_iff.2 ‚ü® included_refl, h‚ÇÇ ‚ü©

theorem vehicle_on_comp {Œ∏ œÜ : Subst Œ± Œ≤} {A : Fintype Œ≤}
  (h‚ÇÅ : ùí± Œ∏ ‚äÜ A) (h‚ÇÇ : ùí± œÜ ‚äÜ A) : ùí± (Œ∏ * œÜ) ‚äÜ A := by
  apply Fintype.image_in_of_all_in
  intro x h
  rw [carrier_spec] at h
  simp only [] -- Better way to do it ?
  rw [‚Üê RAction.smul_mul]
  byCases hŒ∏ : (Term.Var x : Term Œ± Œ≤) ‚Ä¢ Œ∏ = Term.Var x
  focus
    have hœÜ := show (Term.Var x : Term Œ± Œ≤) ‚Ä¢ œÜ ‚â† Term.Var x by
      intro hœÜ
      apply h
      rw [‚Üê RAction.smul_mul, hŒ∏, hœÜ]
    rw [hŒ∏]
    apply included_trans _ h‚ÇÇ
    exact Fintype.in_image_of_is_image <| carrier_spec.2 hœÜ
  focus
    apply vehicle_on_image_contained h‚ÇÇ
    -- The pattern of the two following lines occurs often.
    -- Make it a lemma ?
    apply included_trans _ h‚ÇÅ
    exact Fintype.in_image_of_is_image <| carrier_spec.2 hŒ∏

theorem vehicle_on_comp‚ÇÅ (Œ∏ œÜ : Subst Œ± Œ≤) : 
  (ùí± (Œ∏ * œÜ) : Fintype Œ≤) ‚äÜ ùí± Œ∏ ‚à™ ùí± œÜ := vehicle_on_comp
  (included_union_iff.2 ‚àò Or.inl <| included_refl)
  (included_union_iff.2 ‚àò Or.inr <| included_refl)

theorem cons_vehicle_in {Œ∏ œÜ : Subst Œ± Œ≤} {l‚ÇÅ r‚ÇÅ l‚ÇÇ r‚ÇÇ : Term Œ± Œ≤}
  (h‚ÇÅ : (ùí± Œ∏ : Fintype Œ≤) ‚äÜ ùí± l‚ÇÅ ‚à™ ùí± l‚ÇÇ)
  (h‚ÇÇ : (ùí± œÜ : Fintype Œ≤) ‚äÜ ùí± (r‚ÇÅ ‚Ä¢ Œ∏) ‚à™ ùí± (r‚ÇÇ ‚Ä¢ Œ∏)) :
  (ùí± (Œ∏ * œÜ) : Fintype Œ≤) ‚äÜ ùí± (Term.Cons l‚ÇÅ r‚ÇÅ) ‚à™ ùí± (Term.Cons l‚ÇÇ r‚ÇÇ) := by
  rw [vehicle_cons, vehicle_cons]
  apply included_trans (vehicle_on_comp‚ÇÅ Œ∏ œÜ)
  rw [union_included_iff]; apply And.intro
  focus
    apply included_trans h‚ÇÅ
    conv =>
      rhs
      rw [‚Üê Fintype.union_assoc]
      lhs
      conv => rw [Fintype.union_assoc]; rhs; rw [union_comm]
      rw [‚Üê Fintype.union_assoc]
    rw [Fintype.union_assoc]
    apply included_union_iff.2 ‚àò Or.inl
    exact included_refl
  focus
    apply included_trans h‚ÇÇ
    suffices h : (ùí± (r‚ÇÅ ‚Ä¢ Œ∏) ‚à™ ùí± (r‚ÇÇ ‚Ä¢ Œ∏) : Fintype Œ≤)
      ‚äÜ ùí± l‚ÇÅ ‚à™ ùí± l‚ÇÇ ‚à™ ùí± r‚ÇÅ ‚à™ (ùí± l‚ÇÅ ‚à™ ùí± l‚ÇÇ ‚à™ ùí± r‚ÇÇ) by
      apply included_trans h
      simp only [‚Üê Fintype.union_assoc]
      -- Let's use our hacky lemmas
      simp only [flush_union_left (ùí± l‚ÇÇ)]
      simp only [flush_union_left (ùí± l‚ÇÅ)]
      simp only [union_idempotent, union_idempotent']
      exact included_refl
    apply union_on_included
      <;> apply vehicle_on_image_contained
      <;> first
        | apply included_trans h‚ÇÅ
          apply included_union_iff.2 ‚àò Or.inl
          exact included_refl
        | apply included_union_iff.2 ‚àò Or.inr
          exact included_refl

end

section

variable {Œ± Œ≤ : Type u}

def vanishing (Œ∏ : Subst Œ± Œ≤) :=
  ‚àÄ {x}, (Term.Var x : Term Œ± Œ≤) ‚Ä¢ Œ∏ ‚â† Term.Var x ‚Üí
    ‚àÄ y, ¬¨ (x ‚àà (ùí± ((Term.Var y : Term Œ± Œ≤) ‚Ä¢ Œ∏) : Fintype Œ≤))

theorem vanishing_on_term {Œ∏ : Subst Œ± Œ≤} (h‚ÇÅ : vanishing Œ∏)
  {x : Œ≤} (h‚ÇÇ : (Term.Var x : Term Œ± Œ≤) ‚Ä¢ Œ∏ ‚â† Term.Var x)
  (u : Term Œ± Œ≤) : ¬¨ x ‚àà (ùí± (u ‚Ä¢ Œ∏) : Fintype Œ≤) := by
  induction u with
  | Cst c => match Œ∏ with
    | ‚ü® Œ∏, h ‚ü© => intro h; exact h
  | Var y => exact h‚ÇÅ h‚ÇÇ _
  | Cons l r hl hr =>
    rw [subst_cons]
    intro h
    rw [mem_iff_singleton_included] at h
    let h := included_union_iff.1 h
    simp only [‚Üê mem_iff_singleton_included] at h
    cases h with
    | inl h => exact hl h
    | inr h => exact hr h

theorem vanishing_on_vehicle {Œ∏ : Subst Œ± Œ≤} (h‚ÇÅ : vanishing Œ∏)
  {x : Œ≤} (h‚ÇÇ : (Term.Var x : Term Œ± Œ≤) ‚Ä¢ Œ∏ ‚â† Term.Var x) :
  ¬¨ x ‚àà (ùí± Œ∏ : Fintype Œ≤) := by
  suffices h : ùí± Œ∏ ‚äÜ ùí± Œ∏ \ (Fintype.mk [x]) by
    apply not_mem_iff_in_without.2
    exact h
  apply Fintype.image_in_of_all_in
  intro a h
  apply included_trans _
    <| included_without_of_included _
    <| Fintype.in_image_of_is_image h
  apply not_mem_iff_in_without.1
  apply vanishing_on_term h‚ÇÅ h‚ÇÇ

theorem vanishing_respects_vehicle {Œ∏ : Subst Œ± Œ≤} (h‚ÇÅ : vanishing Œ∏) {x : Œ≤}
  (h‚ÇÇ : ¬¨ x ‚àà (ùí± Œ∏ : Fintype Œ≤)) {u : Term Œ± Œ≤} (h‚ÇÉ : ¬¨ x ‚àà (ùí± u : Fintype Œ≤)) :
  ¬¨ x ‚àà (ùí± (u ‚Ä¢ Œ∏) : Fintype Œ≤) := by
  apply not_mem_of_superset_not_mem (vehicle_on_image included_refl _)
  intro h
  rw [Fintype.mem_union_iff] at h
  exact match h with
  | Or.inl h => h‚ÇÇ h
  | Or.inr h => h‚ÇÉ h

theorem cons_vanishing {Œ∏ œÜ : Subst Œ± Œ≤} {l‚ÇÅ r‚ÇÅ l‚ÇÇ r‚ÇÇ : Term Œ± Œ≤}
  (h‚ÇÅ : (ùí± Œ∏ : Fintype Œ≤) ‚äÜ ùí± l‚ÇÅ ‚à™ ùí± l‚ÇÇ)
  (h‚ÇÇ : (ùí± œÜ : Fintype Œ≤) ‚äÜ ùí± (r‚ÇÅ ‚Ä¢ Œ∏) ‚à™ ùí± (r‚ÇÇ ‚Ä¢ Œ∏))
  (h‚ÇÉ : vanishing Œ∏) (h‚ÇÑ : vanishing œÜ) : vanishing (Œ∏ * œÜ) := by
  intro x hx y
  byCases hŒ∏ : (Term.Var x : Term Œ± Œ≤) ‚Ä¢ Œ∏ = Term.Var x
  focus
    let p := show (Term.Var x : Term Œ± Œ≤) ‚Ä¢ œÜ ‚â† Term.Var x by
      intro hœÜ
      apply hx
      rw [‚Üê RAction.smul_mul, hŒ∏, hœÜ]
    rw [‚Üê RAction.smul_mul]
    apply vanishing_on_term h‚ÇÑ p
  focus
    let p := show ¬¨ x ‚àà (ùí± œÜ : Fintype Œ≤) by
      apply not_mem_of_superset_not_mem h‚ÇÇ
      intro h
      rw [Fintype.mem_union_iff] at h
      exact match h with
      | Or.inl h => (vanishing_on_term h‚ÇÉ hŒ∏ r‚ÇÅ) h
      | Or.inr h => (vanishing_on_term h‚ÇÉ hŒ∏ r‚ÇÇ) h
    rw [‚Üê RAction.smul_mul]
    exact vanishing_respects_vehicle h‚ÇÑ p (h‚ÇÉ hŒ∏ _)

end

section

variable {œá : Type u} (Œ± : Type u) [Monoid Œ±] [RAction œá Œ±]

def unifiers (a b : œá) := Œª (Œ∏ : Œ±) => a ‚Ä¢ Œ∏ = b ‚Ä¢ Œ∏

def generated_by (Œ∏ : Œ±) := Œª (œÜ : Œ±) => ‚àÉ œÅ, Œ∏ * œÅ = œÜ

def is_mgu (a b : œá) (Œ∏ : Œ±) := unifiers Œ± a b = generated_by Œ± Œ∏
def strangers (a b : œá) := unifiers Œ± a b = Œª _ => False

def mgu_or_strangers (a b : œá) :=
  (‚àÉ Œ∏ : Œ±, unifiers Œ± a b = generated_by Œ± Œ∏) ‚à® strangers Œ± a b

end

section

variable {œá : Type u} {Œ± : Type u} [Monoid Œ±] [RAction œá Œ±]

theorem unifies_of_mgu {u v : œá} {Œ∏ : Œ±} (h : is_mgu Œ± u v Œ∏) : u ‚Ä¢ Œ∏ = v ‚Ä¢ Œ∏ := by
  suffices unifiers _ _ _ _ by assumption
  exact h ‚ñ∏ Exists.intro 1 (Monoid.mul_one _)

theorem most_general_of_mgu {a b : œá} {Œ∏ œÜ : Œ±}
  (h‚ÇÅ : is_mgu Œ± a b Œ∏) (h‚ÇÇ : a ‚Ä¢ œÜ = b ‚Ä¢ œÜ) : ‚àÉ œÅ, Œ∏ * œÅ = œÜ := by
  suffices generated_by Œ± Œ∏ œÜ by assumption
  exact h‚ÇÅ ‚ñ∏ h‚ÇÇ

theorem mgu_of_unifies_and_most_general {a b : œá} {Œ∏ : Œ±}
  (unifies : a ‚Ä¢ Œ∏ = b ‚Ä¢ Œ∏)
  (most_general : ‚àÄ œÜ, a ‚Ä¢ œÜ = b ‚Ä¢ œÜ ‚Üí ‚àÉ œÅ, Œ∏ * œÅ = œÜ) : is_mgu Œ± a b Œ∏ := by
  funext œÜ
  apply propext
  apply Iff.intro (most_general _)
  intro ‚ü® œÅ, hœÅ ‚ü©
  rw [‚Üê hœÅ, ‚Üê RAction.smul_mul, ‚Üê RAction.smul_mul, unifies]

end

section

theorem lex_of_le_and_lt {Œ± Œ≤ : Type u}
  {ha : WellFoundedRelation Œ±} {hb : WellFoundedRelation Œ≤}
  {a‚ÇÅ a‚ÇÇ : Œ±} {b‚ÇÅ b‚ÇÇ : Œ≤} (h‚ÇÅ : ha.rel a‚ÇÅ a‚ÇÇ ‚à® a‚ÇÅ = a‚ÇÇ) (h‚ÇÇ : hb.rel b‚ÇÅ b‚ÇÇ) :
  (Prod.lex ha hb).rel (a‚ÇÅ, b‚ÇÅ) (a‚ÇÇ, b‚ÇÇ) := sorry

end

section

variable {Œ± Œ≤ : Type u} [Monoid Œ±]

theorem smul_cons_eq {l r : Term Œ± Œ≤} {Œ∏ : Subst Œ± Œ≤} :
  (Term.Cons l r) ‚Ä¢ Œ∏ = (Term.Cons (l ‚Ä¢ Œ∏) (r ‚Ä¢ Œ∏)) :=
  match Œ∏ with
  | ‚ü® Œ∏, hŒ∏ ‚ü© => rfl

private theorem cons_mgu {l‚ÇÅ r‚ÇÅ l‚ÇÇ r‚ÇÇ : Term Œ± Œ≤} {Œ∏ œÜ : Subst Œ± Œ≤}
  (Œ∏_mgu : is_mgu _ l‚ÇÅ l‚ÇÇ Œ∏) (œÜ_mgu : is_mgu _ (r‚ÇÅ ‚Ä¢ Œ∏) (r‚ÇÇ ‚Ä¢ Œ∏) œÜ) :
  is_mgu _ (Term.Cons l‚ÇÅ r‚ÇÅ) (Term.Cons l‚ÇÇ r‚ÇÇ) (Œ∏ * œÜ) := by
  apply mgu_of_unifies_and_most_general
  focus
    simp [smul_cons_eq, ‚Üê RAction.smul_mul,
      unifies_of_mgu Œ∏_mgu, unifies_of_mgu œÜ_mgu]
  focus
    intro
    simp [smul_cons_eq]
    intro ‚ü® h‚ÇÅ, h‚ÇÇ ‚ü©
    let ‚ü® œÅ‚ÇÅ, hœÅ‚ÇÅ ‚ü© := most_general_of_mgu Œ∏_mgu h‚ÇÅ
    rw [‚Üê hœÅ‚ÇÅ, ‚Üê RAction.smul_mul, ‚Üê RAction.smul_mul] at h‚ÇÇ
    let ‚ü® œÅ‚ÇÇ, hœÅ‚ÇÇ ‚ü© := most_general_of_mgu œÜ_mgu h‚ÇÇ
    exact ‚ü® œÅ‚ÇÇ, (Monoid.mul_assoc _ _ _ ‚ñ∏ hœÅ‚ÇÇ ‚ñ∏ hœÅ‚ÇÅ ‚ñ∏ rfl) ‚ü©

private def rel : WellFoundedRelation (Term Œ± Œ≤ √ó Term Œ± Œ≤) :=
  invImage (Œª (u, v) => ((ùí± u ‚à™ ùí± v : Fintype Œ≤), (u, v)))
  <| Prod.lex
    (Fintype.included_wfRel)
    (Prod.rprod Term.depth_wfRel Term.depth_wfRel)

@[inline]
private def P (x : Term Œ± Œ≤ √ó Term Œ± Œ≤) := match x with
  | (u, v) => strangers (Subst Œ± Œ≤) u v
    ‚à® ‚àÉ Œ∏ : Subst Œ± Œ≤, is_mgu _ u v Œ∏
      ‚àß (ùí± Œ∏ : Fintype Œ≤) ‚äÜ ùí± u ‚à™ ùí± v
      ‚àß vanishing Œ∏

private def robinsonR (x : Term Œ± Œ≤ √ó Term Œ± Œ≤)
  (rh : ‚àÄ y, rel.rel y x ‚Üí P y) : P x := match x with
  | (Term.Cons l‚ÇÅ r‚ÇÅ, Term.Cons l‚ÇÇ r‚ÇÇ) =>
    let p := show rel.rel (l‚ÇÅ, l‚ÇÇ) (Term.Cons l‚ÇÅ r‚ÇÅ, Term.Cons l‚ÇÇ r‚ÇÇ) by
      simp [rel, invImage, InvImage]
      apply lex_of_le_and_lt
      focus
        simp [invImage, InvImage, Fintype.included_wfRel]
        -- Some calculations to do...
        admit
      focus
        exact Prod.RProd.intro (depth_decr_l _ _) (depth_decr_l _ _)
    match rh (l‚ÇÅ, l‚ÇÇ) p with
    | Or.inl h => by
      apply Or.inl
      admit
    | Or.inr ‚ü® Œ∏, Œ∏_mgu, hŒ∏ ‚ü© =>
      let p := show rel.rel (r‚ÇÅ ‚Ä¢ Œ∏, r‚ÇÇ ‚Ä¢ Œ∏) (Term.Cons l‚ÇÅ r‚ÇÅ, Term.Cons l‚ÇÇ r‚ÇÇ) by
        byCases h : Œ∏ = 1
        focus
          rw [h, RAction.smul_one, RAction.smul_one]
          apply lex_of_le_and_lt
          focus
            -- Same calculations as above...
            admit
          focus
            exact Prod.RProd.intro (depth_decr_r _ _) (depth_decr_r _ _)
        focus
          admit
      match rh (r‚ÇÅ ‚Ä¢ Œ∏, r‚ÇÇ ‚Ä¢ Œ∏) p with
      | Or.inl h => by
        apply Or.inl
        admit
      | Or.inr ‚ü® œÜ, œÜ_mgu, hœÜ ‚ü© => by
        apply Or.inr
        apply Exists.intro (Œ∏ * œÜ)
        apply And.intro
        focus
          exact cons_mgu Œ∏_mgu œÜ_mgu
        focus
          exact ‚ü® cons_vehicle_in hŒ∏.1 hœÜ.1,
            cons_vanishing hŒ∏.1 hœÜ.1 hŒ∏.2 hœÜ.2 ‚ü©
  | (Term.Var x, Term.Var y) => by
    byCases p : x = y
    focus
      apply Or.inr ‚àò Exists.intro 1
      rw [p]
      apply And.intro
      focus
        simp [is_mgu]
        funext x
        apply propext
        simp [unifiers, generated_by]
        admit
      focus
        apply And.intro
        focus
          admit
        focus
          exact Œª h => False.elim (h rfl)
    focus
      admit
  | (Term.Cst a, Term.Cst b) => by
    admit -- Same as (Term.Var x, Term.Var y) ?
  | _ => sorry

/-
-- robinson._unary is undefined :'(
def robinson (u v : Term Œ± Œ≤) : Option (Subst Œ± Œ≤) := match (u, v) with
  | (Term.Cons l‚ÇÅ r‚ÇÅ, Term.Cons l‚ÇÇ r‚ÇÇ) =>
    if let some Œ∏ := robinson l‚ÇÅ l‚ÇÇ then
      if let some œÜ := robinson (r‚ÇÅ ‚Ä¢ Œ∏) (r‚ÇÇ ‚Ä¢ Œ∏) then
        some (Œ∏ * œÜ)
      else none
    else none
  | _ => none
termination_by sorry
decreasing_by sorry -/

end
